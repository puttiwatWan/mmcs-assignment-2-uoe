model RefuellingStation
  uses "mmxprs"

  declarations
    nbCustomers: integer  !! number of refuelling stations
    nbSupply: integer     !! number of centralised facilities
  end-declarations

  initialisations from "Dataset1_N25.txt"
	  nbCustomers nbSupply
  end-initialisations

  declarations
    customers = 1..nbCustomers  !! a range of refuelling stations
    supply = 1..nbSupply        !! a range of centralised facilities
    locFacType: set of string   !! types of localized facilities

    !! Demand is the demand for each refuelling station.
    Demand: array(customers) of real
    !! DistCustomerSupply is the distance between each refuelling station and each centralized facility.
    DistCustomerSupply: array(customers, supply) of real
    !! DistCustomer is the distance between each refuelling station.
    DistCustomer: array(customers, customers) of real

    !! LocProdLimit is the production limit for each type of localized facilities.
    LocProdLimit: array(locFacType) of real
    !! MinLocProd is the minimum production required if the localized facility is open.
    MinLocProd: array(locFacType) of real
    !! CenProdLimit is the production limit for each centralized facility.
    CenProdLimit: real
    !! MaxTubePerSite is the mamimum number of tubes that can be used to transport hydrogen to each refuelling station.
    MaxTubePerSite: integer
    !! TubeCap is the capacity of each tube.
    TubeCap: real

    !! CenOpenCost is a cost for opening each centralized facility.
    CenOpenCost: real
    !! TubeTransCost is a cost per km for transporting each tube.
    TubeTransCost: real
    !! EmptyTubeCostReduction is a reduction in cost when transporting an empty tube.
    EmptyTubeCostReduction: real
    !! CenProdCost is a cost per kg when producing hydrogen at a centralized facility.
    CenProdCost: real
    !! LocOpenCost is a cost for opening each type of localized facilities.
    LocOpenCost: array(locFacType) of real
    !! LocProdCost is a cost per kg when producing hydrogen at a localized facility.
    LocProdCost: real
    !! CusOpenCost is a cost for opening each refuelling station.
    CusOpenCost: real

    !! canCover tells if the first refuelling station can cover the second refuelling station (1 = can cover, 0 otherwise).
    !! e.g. canCover(c1,c2) = 1 means that refuelling station c1 can cover for refuelling station c2.
    canCover: array(customers, customers) of integer

    !! cover is whether the first refuelling station is covering the second refuelling station (1 = cover, 0 otherwise).
    !! e.g. cover(c1,c2) = 1 means that refuelling station c1 is covering for refuelling station c2.
    cover: array(customers, customers) of mpvar

    !! station_open tells which stations are open (1 = open, 0 = closed).
    station_open: array(customers) of mpvar

    !! cen_fac_open tells whether each centralized facility is open (1 = open, 0 = closed).
    cen_fac_open: array(supply) of mpvar
    !! loc_fac_open_at tells whether that refuelling station is used as a localized facility.
    !! e.g. loc_fac_open_at(c1, "L") = 1 means that the large localized facility is open at the
    !! refuelling station c1.
    loc_fac_open_at: array(customers, locFacType) of mpvar

    !! cen_prod tells the amount of hydrogen that is transported from each centralized facility
    !! to each refuelling station.
    cen_prod: array(customers, supply) of mpvar
    !! n_tubes is a number of tubes needed to use to transport from each centralized facility to each station
    n_tubes: array(customers, supply) of mpvar
    !! loc_prod tells the amount of hydrogen that is produced at the refuelling station.
    loc_prod: array(customers, locFacType) of mpvar
  end-declarations

  initialisations from "Dataset1_N25.txt"
    Demand DistCustomerSupply DistCustomer locFacType LocProdLimit MinLocProd CenProdLimit
    MaxTubePerSite TubeCap CenOpenCost TubeTransCost EmptyTubeCostReduction CenProdCost
    LocOpenCost LocProdCost CusOpenCost
  end-initialisations

  !! Calculate the cover range for each refuelling station
  forall(c1 in customers, c2 in customers) do
    if(DistCustomer(c1,c2) <= 20) then
      canCover(c1,c2) := 1
    else
      canCover(c1,c2) := 0
    end-if
  end-do

  !! ==================== Objective function ====================
  !! The objective function is to minimized the cost. The total cost can be calculated as:
  !! total_cost = cost for opening each cenralized facility +
  !!              cost for opening each localized facility +
  !!              cost for opening each refuelling station +
  !!              cost for producing each kg at centralized facilities +
  !!              cost for producing each kg at localized facilities +
  !!              cost for tubes transportation back and forth
  total_cost := sum(s in supply) (cen_fac_open(s) * CenOpenCost) +
                sum(c in customers, t in locFacType) (loc_fac_open_at(c,t) * LocOpenCost(t)) +
                sum(c in customers) (station_open(c) * CusOpenCost) +
                sum(c in customers, s in supply) (cen_prod(c,s) * CenProdCost) +
                sum(c in customers, t in locFacType) (loc_prod(c,t) * LocProdCost) +
                sum(c in customers, s in supply) (n_tubes(c,s) * DistCustomerSupply(c,s) * (2 - EmptyTubeCostReduction) * TubeTransCost)
  !! Noted that the (2 - EmptyTubeCostReduction) is for calculating back and forth. When delivery, the cost is just TubeTransCost.
  !! When coming back (with an empty tube), the cost is (1 - EmptyTubeCostReduction) * TubeTransCost. Therefore, combining both,
  !! TubeTransCost + (1 - EmptyTubeCostReduction) * TubeTransCost = (2 - EmptyTubeCostReduction) * TubeTransCost

  !! ==================== Constraints ====================
  !! Each of these variables should be binary
  forall(c in customers) station_open(c) is_binary
  forall(s in supply) cen_fac_open(s) is_binary
  forall(c1 in customers, c2 in customers) cover(c1,c2) is_binary
  forall(c in customers, t in locFacType) loc_fac_open_at(c,t) is_binary

  !! Number of tubes used needs to be an integer
  forall(c in customers, s in supply) n_tubes(c,s) is_integer

  !! Each refuelling station can be covered only once by a capable refuelling station.
  forall(c2 in customers) sum(c1 in customers) cover(c1,c2) * canCover(c1,c2) = 1

  !! Each station can be covered only by an open station
  forall(c1 in customers, c2 in customers) cover(c1,c2) <= station_open(c1)

  !! Any centralized facilities can be open or closed
  sum(s in supply) cen_fac_open(s) <= nbSupply

  !! Each opened refuelling station can only open either a large or small localized facility if needed.
  forall(c in customers) sum(t in locFacType) loc_fac_open_at(c,t) <= station_open(c)

  !! This is a production limit on how much each open centralized facility can produce.
  forall(s in supply) sum(c in customers) cen_prod(c,s) <= cen_fac_open(s) * CenProdLimit

  !! The number of tubes used for each station needs to be a total production in each centralized facility
  !! rounded up to the nearest multiple of TubeCap and then divided by the TubeCap.
  !! E.g. Let the TubeCap be 1000. If the demand is 4600, n_tubes should be 5.
  forall(c in customers, s in supply) n_tubes(c,s) * TubeCap >= cen_prod(c,s)

  !! The number of tubes used for each station cannot exceed the maximum limit.
  !! E.g. If MaxTubePerSite = 7, each station can only be delivered by no more than 7 tubes.
  forall(c in customers) sum(s in supply) n_tubes(c,s) <= MaxTubePerSite

  !! Each localized facility has a minimum and maximum production limit for each type.
  !! loc_fac_open_at is used to apply the constraint only if the localized facility is open
  !! at the refuelling station c.
  forall(c in customers, t in locFacType) do
    loc_prod(c,t) <= loc_fac_open_at(c,t) * LocProdLimit(t)
    loc_prod(c,t) >= loc_fac_open_at(c,t) * MinLocProd(t)
  end-do

  !! The total demand of each refuelling station (own demand + covered stations' demand) should not exceed the
  !! total amount of the production from both centralized and localized facilities that can be transported to
  !! that refuelling station.
  forall(c1 in customers)
    (sum(c2 in customers)(Demand(c2) * cover(c1,c2))) <= (sum(s in supply) cen_prod(c1,s)) + (sum(t in locFacType) loc_prod(c1, t))

  writeln("Begin running model")
  minimize(total_cost)
  writeln("End running model")

  !! ==================== Printing Results ====================
  writeln("==================== Printing Results ====================")
  writeln("The total cost is ", strfmt(getobjval, 0, 2), " Â£.")

  writeln
  forall(c in customers) do
    if (c in 1..9) then
      write("C0", c, " | ")
    else
      write("C", c, " | ")
    end-if
    forall(s in supply) do
      write(strfmt(getsol(cen_prod(c,s)), 14), " | ")
    end-do
    writeln
    writeln("-------------------------------------------------------")
  end-do

  writeln
  forall(c in customers) do
    if (c in 1..9) then
      write("C0", c, " ")
    else
      write("C", c, " ")
    end-if
    write("(", getsol(loc_fac_open_at(c,"L")), ",", getsol(loc_fac_open_at(c,"S")),")")
    write(" | ")
    forall(t in locFacType) do
      write(strfmt(getsol(loc_prod(c,t)), 14), " | ")
    end-do
    writeln
    writeln("---------------------------------------------")
  end-do

  writeln
  writeln("Loc Fac Open At")
  forall(c in customers) do
    if (c in 1..9) then
      write("C0", c)
    else
      write("C", c)
    end-if
    write(" (", getsol(station_open(c)), ") | ")
    forall(t in locFacType) do
      write(getsol(loc_fac_open_at(c,t)), " | ")
    end-do
    writeln
    writeln("-----------------")
  end-do

  writeln
  forall(c in customers) do
    if (c in 1..9) then
      write("C0", c)
    else
      write("C", c)
    end-if
    write(" | ")
    forall(s in supply) do
      write(getsol(n_tubes(c,s)), " | ")
    end-do
    writeln
    writeln("-----------------")
  end-do

  writeln
  forall(c1 in customers) do
    if (c1 in 1..9) then
      write("C0", c1)
    else
      write("C", c1)
    end-if
    write(" (", getsol(station_open(c1)), "): ")
    forall(c2 in customers) do
      if(getsol(cover(c1,c2)) = 1) then
        write("C", c2, " ")
      end-if
    end-do
    writeln
  end-do

  forall(s in supply) do
    writeln("Total prod for C", s, " is ", sum(c in customers) getsol(cen_prod(c,s)))
  end-do
end-model
